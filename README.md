# CodeCraft2025

2025华为软件精英挑战赛西北赛区复赛第9名-有的兄弟,有的-代码仓库及思路

## 前言
本次华为软件杯中，我们团队拿到了西北赛区第9名（二等奖）。该项目为区域赛复赛时使用的代码以及思路详解。

## 算法解析
**核心思路**：分页，按页读取，对象mask

### 全局预处理
全局预处理阶段会给出每个标签在所有时间内的写入、删除、读取的对象长度，以1800个时间片为单位。在这部分数据的处理上，我们根据每个标签在时间上的读取规律计算皮尔逊相似度，并根据相似度来规划存储在磁盘上的位置。

### 写入操作
在存储方面，我们对磁盘的空间进行了预先划分。对于每个磁盘，将其划分为n个页（默认数量为tag数*2），每个页将尽可能存放同一个标签的对象。

在准备写入对象时，会首先获取对象所属标签拥有的所有页，并将页按照剩余容量从小到大排序，即优先写入剩余容量小的页。写入时，遵循3份副本以及硬盘标号不同的原则，跳过不适合写入的页。

如果以上方法不足以写入三个副本，则会触发页申请机制，流程如下：
1. **选盘**：排除掉已经写入过副本的磁盘。对于每个磁盘，计算所需写入的对象标签与盘上所有页标签的相似度，优先选择相似度小的磁盘。同时，如果某个磁盘的剩余容量过小，则会降低优先级。
2. **选页**：完成选盘后，会继续从该磁盘上申请一个页。申请页时，会根据标签之间的相似度和页的剩余容量进行排序，优先将相似的页放在一起，同时优先选择剩余容量大的页。若有尚未被某个标签占据的页，则会在上述算法的基础上优先占据空白页，否则会占据某个已经写有其他标签数据的页，并修改占据该页的标签。

完成页申请后，会将数据写入该页中。重复该过程，直至完成3个副本的写入。

### 删除操作
删除操作较为简单，首先删除磁盘上的数据，之后查询未完成的请求并上报，然后取消数据所对应的读取请求。

### 读取操作
在读取部分，有两个较为重要的机制：按页读取和对象mask

#### 1. 按页读取
指针在读取数据时，最好能够连续地进行读取，减少pass和jump操作的次数。为此，需要不时跳转到数据密度（分数密度）较大的位置，但频繁地跳转和简单的数据密度检测算法带来的效果较差。考虑到每个页中已尽可能存储某一个标签的数据，同时相同标签具有相似的读取特性，因此可以按页为磁头指派任务，并在完成某个页的任务时决定是否跳转。

当磁头完成了某个页的任务时（包括初始状态），磁盘会计算每个页上任务的价值，并按照价值进行排序。考虑到跳转会带来额外的开销，因此在计算磁头将要读取的下一个页的价值时，会额外乘一个补偿系数（代码中为1.2）。根据页的价值，为磁头指派一个价值最高的页，并根据磁头被指派的页进一步规划其行为。

当磁头不位于被指派的页中时，控制磁头跳转到页的起始位置。磁头在页中时，顺序进行读取，并使用动态规划来决定遇到没有数据的块时是否需要继续执行读操作。

#### 2. 对象mask
由于每个对象有3个副本，因此当一个副本已经被某个指针预定（即为某个指针指派了该副本所在的页）时，其余副本仍然会提供价值，引导指针去读取其所在的页。在这种情况下，某些页的价值会被高估，导致磁头的工作效率降低。该现象在复赛磁头较多时尤为明显。

在实现中，我们为对象添加了mask机制，以屏蔽掉已被预订对象的价值，提高磁头工作效率。具体来说，当某个页被选中时，遍历磁盘中的所有对象，并在主程序中维护所有对象被预定的次数。在计算每个页的分数时，只计算尚未被选中的对象分数，之后仍然按照前述流程指派任务。当对象完成读取或是被删除时，清空其对应的预定次数。对于指派了页之后写入的对象，也会检测磁头的工作状态，为该对象设定预定次数。

### 垃圾回收
垃圾回收的本意是降低磁盘的碎片化程度，提高磁头读取效率。程序中主要实现了以下几种整理方式：
1. **页内整理**：将页内的数据向页的起始位置转移，使页内的数据更为紧凑。
2. **页间整理**：针对空间对象的类与页对应的类不一致的数据，将对象转移至自己的类对应的页中。

但我们在实际尝试中发现该机制的提升十分有限。其原因可能有以下几点：
1. 提供的磁盘整理次数过少，对碎片化程度帮助较小。
2. 分页机制本身已经较好地控制了碎片化程度。

### 超时预测
复赛时要求每个读请求都要上报完成或是超时，因此我们使用一个队列来维护每个请求以及到来的时间。在每个时间刻，程序弹出所有已超时的请求，取消其在程序中的任务，并上报繁忙。该机制保证了每个请求都能被及时识别，确保程序正常运行。

由于上报超时会扣分，因此程序中使用了一个预测机制来判别某个对象能否在超时前被读取，如果不能，则立刻上报超时。具体来说，根据每个页的容量和磁头的平均读取速度，就能计算出每个页的读取时间。假设单个磁盘按照页的价值从大到小进行读取，那么就能估算出还有多长时间能够读取到特定对象。使用估计的读取时间与对象的剩余时间做比较，并将预计无法完成的对象上报超时。该估计系统需要计算每个活跃请求的预计完成时间，计算量较大。若每一步都执行该计算，最终运行时间会超出时间限制。因此在实际运行时，改为每隔一定时间执行一次预测，以降低时间开销。

在实际运行中，我们发现估计系统的准确率并不高，估计方差非常大。在分数上，能小幅度降低超时的扣分，提高读取的得分，但仍然有相当比例的读请求在最后时刻才上报繁忙。超时预测部分的效果不佳也导致了我们在复赛正式赛阶段的得分不尽人意，最终未能成功晋级。赛后，我们学习了冠军在该部分的设计思路：维护一个丢弃比例，在请求到来时随机取消丢弃比例的请求，并根据之前时间的超时请求数量来动态调整丢弃比例。这个方法将超时预测与磁盘的读取机制解耦，大幅提高运行效率的同时，也发挥了难以置信的效果。只能说不愧是大道至简。

## 后记
在编程语言上，我们三名成员都擅长python，对C++不甚了解。这导致后期为了追求效率而转为使用C++时，遇到了诸多不便，如python程序转写困难、编程风格不适应等。这些问题也一定程度上影响了我们的开发效率。从最开始构建程序基本框架，到一步一步地修复bug、改进算法。我们付出了很多努力，也在这个过程中学习到了很多宝贵的经验。赛后复盘时，我们所实现的算法与顶尖队伍的结构也基本一致，可以说距离进入决赛就差了超时预测机制的临门一脚。没能公费旅游，多少还是有些遗憾😉，但相比上次参赛颗粒未收来说，也算是小有收获。
